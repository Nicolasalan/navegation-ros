# A frequência, em Hz, na qual o filtro emitirá uma estimativa de posição. Observe que o filtro não será iniciado
# computação até receber pelo menos uma mensagem de uma das entradas. Em seguida, ele funcionará continuamente no
# frequência especificada aqui, independentemente de receber mais medições. O padrão é 30 se não for especificado.
frequency: 200

# O período, em segundos, após o qual consideramos que um sensor atingiu o tempo limite. Neste evento, realizamos uma previsão
# ciclo no EKF sem corrigi-lo. Este parâmetro pode ser pensado como a frequência mínima com que o
# filtro irá gerar uma nova saída. O padrão é 1 / frequência se não for especificado.
sensor_timeout: 0.1

# ekf_localization_node e ukf_localization_node ambos usam um modelo de movimento 3D omnidirecional. Se este parâmetro for
# definido como verdadeiro, nenhuma informação 3D será usada em sua estimativa de estado. Use isso se você estiver operando em um plano
# ambiente e deseja ignorar o efeito de pequenas variações no plano do solo que podem ser detectadas
# por, por exemplo, uma IMU. O padrão é false se não for especificado.
two_d_mode: true

# Use este parâmetro para fornecer um deslocamento para a transformação gerada por ekf_localization_node. Isso pode ser usado para
# data futura da transformação, que é necessária para interação com alguns outros pacotes. O padrão é 0,0 se
# não especificado.
transform_time_offset: 0.0

# Use este parâmetro para especificar quanto tempo o ouvinte tf deve esperar até que uma transformação fique disponível.
# O padrão é 0.0 se não for especificado.
transform_timeout: 0.0

# Se você estiver tendo problemas, tente definir isso como true e, em seguida, ecoe o tópico /diagnostics_agg para ver se o nó está
# descontente com quaisquer configurações ou dados.
print_diagnostics: true

# Configurações de depuração. Não para os fracos de coração. Emite uma quantidade absurda de informações para o arquivo especificado por
# debug_out_file. Espero que gostem de matrizes! Por favor, note que definir isso como verdadeiro terá um efeito altamente deletério
# efeitos no desempenho do nó. O padrão é false se não for especificado.
debug: false

# O padrão é "robot_localization_debug.txt" se não for especificado. Especifique o caminho completo.
debug_out_file: /home/niklas/rbloc_debug.txt

# REP-105 (http://www.ros.org/reps/rep-0105.html) especifica quatro quadros de coordenadas principais: base_link, odom, map e
# terra. base_link é o quadro de coordenadas que é afixado ao robô. Tanto o odom quanto o mapa são quadros fixos no mundo.
# A posição do robô no quadro odom irá variar ao longo do tempo, mas é precisa no curto prazo e deve ser
#contínuo. O quadro odom é, portanto, o melhor quadro para executar planos de movimento local. O quadro do mapa, como o odom
# frame, é um frame de coordenadas fixas em todo o mundo e, embora contenha a estimativa de posição mais precisa globalmente para o seu
# robô, está sujeito a saltos discretos, por exemplo, devido à fusão de dados de GPS ou a uma correção de um mapa
# nó de localização. O quadro terrestre é usado para relacionar vários quadros de mapa, dando-lhes um quadro de referência comum.
# ekf_localization_node e ukf_localization_node não estão preocupados com a estrutura de terra.
# Aqui está como usar as seguintes configurações:
# 1. Defina os quadros map_frame, odom_frame e base_link para os nomes de quadro apropriados para seu sistema.
#1a. Se o seu sistema não tiver um map_frame, apenas remova-o e certifique-se de que "world_frame" esteja definido com o valor de
# odom_frame.
# 2. Se você estiver fundindo dados de posição contínua, como odometria do codificador de roda, odometria visual ou dados IMU, defina
# "world_frame" ao seu valor odom_frame. Este é o comportamento padrão para os nós de estimativa de estado do robot_localization.
# 3. Se você estiver fundindo dados de posição absoluta global que estão sujeitos a saltos discretos (por exemplo, GPS ou atualizações de posição
# de observações de marcos), então:
#3a. Defina seu "world_frame" para o valor do seu map_frame
#3b. CERTIFIQUE-SE de que algo mais está gerando a transformação odom->base_link. Observe que isso pode até ser outro estado
# nó de estimativa de robot_localization! No entanto, essa instância *não* deve fundir os dados globais.
map_frame: map              # Padrões para "mapear" se não especificado
odom_frame: odom            # O padrão é "odom" se não for especificado
base_link_frame: base_link  # O padrão é "base_link" se não for especificado
world_frame: odom           # Padrão para o valor de odom_frame se não for especificado

# O filtro aceita um número arbitrário de entradas de cada tipo de mensagem de entrada (nav_msgs/Odometry,
# geometry_msgs/PoseWithCovarianceStamped, geometry_msgs/TwistWithCovarianceStamped,
# sensor_msgs/Imu). Para adicionar uma entrada, basta anexar o próximo número na sequência ao nome "base", por exemplo, odom0,
# odom1, twist0, twist1, imu0, imu1, imu2, etc. O valor deve ser o nome do tópico. Esses parâmetros obviamente não
# valores padrão e devem ser especificados.
odom0: /odom

# Cada leitura do sensor atualiza alguns ou todos os estados do filtro. Essas opções oferecem maior controle sobre quais
# valores de cada medição são alimentados ao filtro. Por exemplo, se você tiver uma mensagem de odometria como entrada, mas apenas
# deseja usar seu valor de posição Z e, em seguida, defina o vetor inteiro como falso, exceto a terceira entrada. A ordem do
# valores são x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az. Observe que nem alguns tipos de mensagem
# não fornece algumas das variáveis de estado estimadas pelo filtro. Por exemplo, uma mensagem TwistWithCovarianceStamped
# não tem informações de pose, então os primeiros seis valores não teriam sentido nesse caso. Cada vetor padroniza para todos falsos
# se não especificado, tornando este parâmetro efetivamente necessário para cada sensor.

# x, y, z, 
# roll, pitch, yaw, 
# vx, vy, vz, 
# vroll, vpitch, vyaw, 
# ax, ay, az
odom0_config: [true,  true,  false,
               false, false, false,
               true, true, false,
               false, false, true,
               false, false, false]

# Se você tiver dados de alta frequência ou estiver executando com um valor de parâmetro de baixa frequência, talvez queira aumentar
# o tamanho da fila de assinatura para que mais medidas sejam fundidas.
odom0_queue_size: 2

# [AVANÇADO] Mensagens grandes no ROS podem apresentar comportamento estranho quando chegam em alta frequência. Este é um resultado
# do algoritmo de Nagle. Esta opção diz ao assinante do ROS para usar a opção tcpNoDelay, que desabilita o Nagle
#algoritmo.
odom0_nodelay: false

# [AVANÇADO] Ao medir uma variável de pose com dois sensores, pode surgir uma situação em que ambos os sensores
# relatar suas covariâncias. Isso pode fazer com que o filtro salte rapidamente para frente e para trás entre cada medição, à medida que
# chegar. Nesses casos, geralmente faz sentido (a) corrigir as covariâncias de medição ou (b) se a velocidade também for
# medido por um dos sensores, deixe um sensor medir a pose e o outro a velocidade. No entanto, fazer (a) ou (b) não é
# sempre viável, e assim expomos o parâmetro diferencial. Quando o modo diferencial está habilitado, todas as poses absolutas
# os dados são convertidos em dados de velocidade diferenciando as medições de pose absolutas. Essas velocidades são então
# integrado como de costume. OBSERVAÇÃO: isso se aplica apenas a sensores que fornecem medições de pose; definindo o diferencial como verdadeiro
# para medições de torção não tem efeito.
odom0_differential: true

# [ADVANCED] Quando o nó inicia, se este parâmetro for verdadeiro, então a primeira medição é tratada como um "ponto zero"
# para todas as medições futuras. Embora você possa obter o mesmo efeito com o parâmetro diferencial, a chave
# diferença é que o parâmetro relativo não faz com que a medida seja convertida para uma velocidade antes
# integrando-o. Se você simplesmente deseja que suas medições comecem em 0 para um determinado sensor, defina isso como verdadeiro.
odom0_relative: false

# [AVANÇADO] Se seus dados estiverem sujeitos a discrepâncias, use essas configurações de limite, expressas como distâncias de Mahalanobis, para
# controla a distância do estado atual do veículo que uma medição do sensor pode estar. Cada padrão para
# numeric_limits<double>::max() se não for especificado. É altamente recomendável que esses parâmetros sejam removidos se não
# requeridos. Os dados são especificados no nível das variáveis de pose e twist, em vez de para cada variável isoladamente.
# Para mensagens que possuem dados de pose e twist, o parâmetro especifica a qual parte da mensagem estamos aplicando
# os limites.
odom0_pose_rejection_threshold: 5
odom0_twist_rejection_threshold: 1

# IMU
imu0: imu/data_raw

# x, y, z, 
# roll, pitch, yaw, 
# vx, vy, vz, 
# vroll, vpitch, vyaw, 
# ax, ay, az
imu0_config: [false, false, false,
              false, false, false,
              false, false, false,
              false, false, true,
              false, false, false]

imu0_nodelay: false
imu0_differential: false
imu0_relative: true
imu0_queue_size: 5
imu0_pose_rejection_threshold: 0.8                 # Observe a diferença nos nomes dos parâmetros
imu0_twist_rejection_threshold: 0.8                #
imu0_linear_acceleration_rejection_threshold: 0.8  #

# [ADVANCED] Algumas IMUs removem automaticamente a aceleração devido à gravidade e outras não. Se o seu não, por favor, defina
# isso para true, e *certifique-se* de que seus dados estão em conformidade com REP-103, especificamente, que os dados estão no quadro ENU.
imu0_remove_gravitational_acceleration: true

# [AVANÇADO] Os modelos EKF e UKF seguem um ciclo padrão de previsão/correção. Durante a previsão, se não houver
# referência de aceleração, a velocidade no tempo t+1 é simplesmente prevista para ser a mesma que a velocidade no tempo t. Durante
# correção, este valor previsto é fundido com o valor medido para produzir a nova estimativa de velocidade. Isso pode ser
# problemático, pois a velocidade final será efetivamente uma média ponderada da velocidade antiga e da nova. Quando
# esta velocidade é integrada em uma nova pose, o resultado pode ser uma cobertura lenta. Este efeito é especialmente
# perceptível com dados LIDAR durante as rotações. Para contornar isso, os usuários podem tentar inflar o process_noise_covariance
# para a variável de velocidade em questão ou diminuir a variância da variável em questão na medição
# em si. Além disso, os usuários também podem aproveitar o comando de controle emitido para o robô no momento em que
# faça a previsão. Se o controle for usado, ele será convertido em um termo de aceleração, que será usado durante
# previsão. Observe que se uma medida de aceleração para a variável em questão estiver disponível em um dos
# entradas, o termo de controle será ignorado.
# Se usamos ou não a entrada de controle durante a previsão. O padrão é falso.
use_control: true
# Se a entrada (supostamente cmd_vel) é uma mensagem geometry_msgs/Twist ou geometry_msgs/TwistStamped. Padrões para
#falso.
stamped_control: false
# O último comando de controle emitido será usado na previsão para este período. O padrão é 0,2.
control_timeout: 0.1
# Quais velocidades estão sendo controladas. A ordem é vx, vy, vz, vroll, vpitch, vyaw.
control_config: [true, false, false, false, false, true]
# Coloca limites em quão grande será o termo de aceleração. Deve corresponder à cinemática do seu robô.
acceleration_limits: [1.3, 0.0, 0.0, 0.0, 0.0, 3.4]
# Os limites de aceleração e desaceleração nem sempre são os mesmos para robôs.
deceleration_limits: [1.3, 0.0, 0.0, 0.0, 0.0, 4.5]
# Se o seu robô não pode atingir instantaneamente seu limite de aceleração, a mudança permitida pode ser controlada com estes
# ganhos
acceleration_gains: [0.8, 0.0, 0.0, 0.0, 0.0, 0.9]
# Se o seu robô não pode atingir instantaneamente seu limite de desaceleração, a mudança permitida pode ser controlada com estes
# ganhos
deceleration_gains: [1.0, 0.0, 0.0, 0.0, 0.0, 1.0]

# [AVANÇADO] A matriz de covariância de ruído do processo pode ser difícil de ajustar e pode variar para cada aplicação, por isso é
# exposto como parâmetro de configuração. Esta matriz representa o ruído que adicionamos ao erro total após cada
# etapa de previsão. Quanto melhor o modelo de movimento omnidirecional corresponder ao seu sistema, menores poderão ser esses valores.
# No entanto, se os usuários acharem que uma determinada variável é lenta para convergir, uma abordagem é aumentar o
# process_noise_covariance valor diagonal para a variável em questão, que causará o erro previsto do filtro
# seja maior, o que fará com que o filtro confie mais na medição recebida durante a correção. Os valores são
# ordenados como x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az. Padrões para a matriz abaixo se
# não especificado.
process_noise_covariance: [0.05, 0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0.05, 0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0.06, 0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0.03, 0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0.03, 0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0.06, 0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0.025, 0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0.025, 0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0.04, 0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0.01, 0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0.01, 0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0.1,  0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0.01, 0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0.01, 0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0.015]

# [ADVANCED] Isso representa o valor inicial para a matriz de covariância de erro de estimativa de estado. Definir uma diagonal
# valor (variância) para um valor grande resultará em convergência rápida para medições iniciais da variável em
# pergunta. Os usuários devem tomar cuidado para não usar valores grandes para variáveis que não serão medidas diretamente. Os valores
# são ordenados como x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az. Padrões para a matriz abaixo
#se não especificado.
initial_estimate_covariance: [1e-9, 0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                              0,    1e-9, 0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                              0,    0,    1e-9, 0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                              0,    0,    0,    1e-9, 0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                              0,    0,    0,    0,    1e-9, 0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                              0,    0,    0,    0,    0,    1e-9, 0,    0,    0,    0,     0,     0,     0,    0,    0,
                              0,    0,    0,    0,    0,    0,    1e-9, 0,    0,    0,     0,     0,     0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,    1e-9, 0,    0,     0,     0,     0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,    0,    1e-9, 0,     0,     0,     0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,    0,    0,    1e-9,  0,     0,     0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     1e-9,  0,     0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     1e-9,  0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     1e-9, 0,    0,
                              0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    1e-9, 0,
                              0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    1e-9]

# [ADVANCED, UKF ONLY] As variáveis alfa e kappa controlam a distribuição dos pontos sigma. A menos que você esteja familiarizado
# com UKFs, provavelmente é uma boa ideia deixá-los em paz.
# O padrão é 0,001 se não for especificado.
alpha: 0.001
# O padrão é 0 se não for especificado.
kappa: 0

# [ADVANCED, UKF ONLY] A variável beta refere-se à distribuição do vetor de estado. Novamente, provavelmente é melhor
# deixe isso em paz se você não tiver certeza. O padrão é 2 se não especificado.
beta: 2