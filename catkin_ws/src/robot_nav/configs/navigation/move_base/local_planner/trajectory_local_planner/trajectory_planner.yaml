TrajectoryPlannerROS: 

 acc_lim_x  : 2.5  
 # O limite de aceleração x do robô em metros/seg^2

 acc_lim_y  : 2.5  
 # O limite de aceleração y do robô em metros/seg^2 

 acc_lim_theta  : 3.2  
 # O limite de aceleração rotacional do robô em radianos/s^2 

 max_vel_x  : 0.8  
 # A velocidade máxima de avanço permitida para a base em metros/s

 min_vel_x  : 0.1  
 # A velocidade mínima de avanço permitida para a base em metros/seg. É útil especificar isso para garantir que os comandos de velocidade enviados para uma base móvel sejam altos o suficiente para permitir que a base supere o #friction. 

 max_vel_theta  : 1.0  
 # A velocidade de rotação máxima permitida para a base em radianos/s 

 min_vel_theta  : -1.0  
 # A velocidade de rotação mínima permitida para a base em radianos/s 

 min_in_place_vel_theta  : 0.4  
 # A velocidade rotacional mínima permitida para a base durante a execução de rotações no local em radianos/s  

 escape_vel  : -0.1  
 # Velocidade utilizada para condução em fugas em metros/seg. Observe que deve ser negativo para que o robô realmente reverta. Uma velocidade positiva fará com que o robô avance enquanto tenta #escapar. Novo na navegação 1.3.1 

 holonomic_robot  : true  
 # Determina se os comandos de velocidade são gerados para um robô holonômico ou não holonômico. Para robôs holonômicos, comandos de velocidade de ataque podem ser emitidos para a base. Para robôs não holonômicos, nenhum comando de velocidade #strafing será emitido. 

# Os parâmetros a seguir são usados apenas se holonomic_robot for definido como true:

 y_vels : [-0.1, -0.1, 0.1, 0.1]  
 # As velocidades de strafing que um robô holonômico considerará em metros/s 

### Parâmetros de tolerância da meta

 yaw_goal_tolerance  : 0.05  
 # A tolerância em radianos para o controlador em guinada/rotação ao atingir seu objetivo 

 xy_goal_tolerance  : 0.10  
 # A tolerância em metros para o controlador na distância x e y ao atingir uma meta 

 latch_xy_goal_tolerance  : false  
 # Se a tolerância da meta estiver travada, se o robô chegar ao local xy da meta, ele simplesmente girará no lugar, mesmo que termine fora da tolerância da meta enquanto estiver fazendo isso. - Novo na navegação 1.3.1 

### Parâmetros de simulação de encaminhamento

 sim_time  : 1.0  
 # A quantidade de tempo para simular trajetórias em segundos 

 sim_granularity  : 0.025  
 # O tamanho do passo, em metros, a ser percorrido entre pontos em uma determinada trajetória 

 angular_sim_granularity  :  sim_granularity  
 # O tamanho do passo, em radianos, a ser obtido entre amostras angulares em uma determinada trajetória. - Novo na navegação 1.3.1 

 vx_samples : 20  
 # O número de amostras a serem usadas ao explorar o espaço de velocidade x 

 vtheta_samples : 40  
 # O número de amostras a serem usadas ao explorar o espaço de velocidade teta 

### Parâmetros de pontuação da trajetória

 meter_scoring  : false  
 # Se os parâmetros gdist_scale e pdist_scale devem assumir que goal_distance e path_distance são expressos em unidades de metros ou células. As células são assumidas por padrão. Novo na navegação 1.3.1

 pdist_scale : 0.9  
 # A ponderação de quanto o controlador deve ficar próximo ao caminho que lhe foi dado, o valor máximo possível é 5.0

 gdist_scale : 0.6  
 # A ponderação de quanto o controlador deve tentar atingir seu objetivo local, também controla a velocidade, o valor máximo possível é 5,0 

 occdist_scale : 0.01  
 # A ponderação de quanto o controlador deve tentar evitar obstáculos 

 heading_lookahead : 0.325 # Em metros
 # O quão longe olhar para frente em metros ao marcar diferentes trajetórias de rotação no local 

 heading_scoring  : false  
 #Seja pontuar com base no rumo do robô para o caminho ou sua distância do caminho 

 heading_scoring_timestep : 1.0  
 # Quanto olhar para frente no tempo em segundos ao longo da trajetória simulada ao usar a pontuação de direção 

 dwa  : true  
 # Se usar a abordagem de janela dinâmica (DWA _ ou se usar o rollout de trajetória (OBSERVAÇÃO: em nossa experiência, o DWA funcionou tão bem quanto o rollout de trajetória e é computacionalmente mais barato. É possível que robôs com limites de aceleração extremamente baixos possam ganhar com a execução Lançamento de trajetória, mas recomendamos experimentar o DWA primeiro.   

 publish_cost_grid_pc  : false  
 # Publicar ou não a grade de custos que o planejador usará no planejamento. Quando verdadeiro, um sensor_msgs/PointCloud2 estará disponível no tópico cost_cloud. Cada nuvem de pontos representa o #grid de custo e possui um campo para cada componente individual da função de pontuação, bem como o custo geral de cada célula, levando em consideração os parâmetros de pontuação. Novo na navegação 1.4.0 

 
### Parâmetros de prevenção de oscilação

 oscillation_reset_dist : 0.05  
 # Qual a distância que o robô deve percorrer em metros antes que os sinalizadores de oscilação sejam redefinidos

### Parâmetros do Plano Global

 prune_plan  : true  
 # Define se deve ou não consumir o plano à medida que o robô se move ao longo do caminho. Se definido como verdadeiro, os pontos cairão no final do plano quando o robô passar 1 metro além deles.
