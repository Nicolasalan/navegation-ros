TebLocalPlannerROS:

####################################################
# Parâmetros de configuração do robô
####################################################
 acc_lim_x: 0.25
 # Aceleração translacional máxima do robô em metros/s^2 

 acc_lim_theta: 0.8
 # Aceleração angular máxima do robô em radianos/s^2 

 max_vel_x: 0.6
 # Velocidade máxima de translação do robô em metros/s

 max_vel_x_backwards: 0.4
 # Velocidade de translação absoluta máxima do robô durante a marcha para trás em metros/seg. Consulte o parâmetro de otimização weight_kinematics_forward_drive

 max_vel_theta: 0.8
 # Velocidade angular máxima do robô em radianos/s
 
 footprint_model/type: "line"
 # Especifique o tipo de modelo de pegada do robô usado para otimização. Diferentes tipos são "ponto", "circular", "linha",
 # "two_circles" e "polygon."
 # O tipo do modelo influencia significativamente o tempo de computação necessário.

############################
### Tipo de ponto
############################

# nenhum outro parâmetro necessário

############################
### Digite a linha
############################
 footprint_model/line_start: [-0.4, 0.0] 
 # Este parâmetro só é relevante para o tipo "linha". Ele contém as coordenadas iniciais do segmento de linha.

 footprint_model/line_end: [0.4, 0.0]
 # Este parâmetro só é relevante para o tipo "linha". Ele contém as coordenadas finais do segmento de linha.

############################
### Para robôs holonômicos
############################
 max_vel_y: 0.6

 acc_lim_y: 0.25

 # Defina ambos como 0.0 para não-holonômico

####################################################
# Parâmetros de tolerância da meta 
####################################################
 xy_goal_tolerance: 0.05
 # Permitida a distância euclidiana final até a posição do gol em metros 

 yaw_goal_tolerance: 0.02
 # Permitido erro de orientação final em radianos 

 free_goal_vel: false
 # Remova a restrição de velocidade do objetivo para que o robô possa chegar ao objetivo com velocidade máxima

####################################################
# Parâmetros de configuração da trajetória
####################################################
 dt_ref: 0.3
 # Resolução temporal desejada da trajetória

 dt_hysteresis: 0.1
 # Hysteresis para redimensionamento automático dependendo da resolução temporal atual,
 # geralmente aprox. 10% de dt_ref é recomendado

 min_samples: 3
 # Número mínimo de amostras

 global_plan_overwrite_orientation: true
 #Sobrescrever a orientação de subobjetivos locais fornecidos pelo planejador global (já que eles geralmente fornecem apenas um caminho 2D)

 global_plan_viapoint_sep: -0.1
 # Se positivo, os pontos de via são extraídos do plano global (modo de acompanhamento de caminho).
 # O valor determina a resolução do caminho de referência (separação mínima entre cada dois pontos de passagem consecutivos ao longo do plano global,
 # Se negativo (desativado). Consulte o parâmetro weight_viapoint para ajustar a intensidade. Novo na versão 0.4

 max_global_plan_lookahead_dist: 100.0
 # Especifique o comprimento máximo (distâncias euclidianas cumulativas) do subconjunto do plano global considerado para otimização.
 # O comprimento real é determinado pela conjunção lógica do tamanho do mapa de custos local e esse limite máximo.
 # Definir como zero ou negativo para desativar esta limitação.

 force_reinit_new_goal_dist: 1.0
 # Reinicializa a trajetória se uma meta anterior for atualizada com uma separação maior que o valor especificado em metros 

 feasibility_check_no_poses : 4
 # Especifique até qual pose no plano previsto a viabilidade deve ser verificada a cada intervalo de amostragem. 

 shrink_horizon_backup: true
 # Permite que o planejador reduza o horizonte temporariamente (50%) em caso de problemas detectados automaticamente (por exemplo, inviabilidade).
 # Veja também o parâmetro shrink_horizon_min_duration.

 publish_feedback: false
 # Publique o feedback do planejador contendo a trajetória completa e uma lista de obstáculos ativos
 # (deve ser ativado apenas para avaliação ou depuração. Veja a lista de editores acima. 

 allow_init_with_backwards_motion: true
 # permite movimento para trás caso o gol atrás do início

 exact_arc_length: true
 # Se verdadeiro, o planejador usa o comprimento exato do arco em velocidade rápida, e taxa de giro
 # (-> aumento do tempo de CPU), caso contrário, a aproximação euclidiana é usada.

 shrink_horizon_min_duration: 10.0
 # Especifique a duração mínima para o horizonte reduzido caso seja detectada uma trajetória inviável
 # (consulte o parâmetro shrink_horizon_backup para ativar o modo de horizonte reduzido).

####################################################
# Parâmetros de obstáculo
####################################################

 min_obstacle_dist: 0.6
 # Separação mínima desejada de obstáculos em metros 

 include_costmap_obstacles: true
 # Especifique se os obstáculos do mapa de custos local devem ser levados em consideração. Cada célula marcada como
 # obstacle é considerado um ponto-obstáculo. Portanto, não escolha uma resolução muito pequena do mapa de custos
 # pois aumenta o tempo de computação. Em versões futuras, essa circunstância será abordada como
 # bem como fornecer uma API adicional para obstáculos dinâmicos.

 costmap_obstacles_behind_robot_dist: 1.0
 # Limite os obstáculos do mapa de custos locais ocupados levados em consideração para o planejamento atrás do robô (especifique a distância em metros).

 obstacle_poses_affected: 30
 # Cada posição de obstáculo é anexada à pose mais próxima da trajetória para manter a distância.
 # Vizinhos adicionais também podem ser levados em consideração. Observe que esse parâmetro pode ser removido em versões futuras,
 # desde que a estratégia de associação de obstáculos foi modificada no kinetic+. Consulte a descrição do parâmetro de legacy_obstacle_association.

 inflation_dist: 0.8
 # Zona de buffer em torno de obstáculos com custos de penalidade diferentes de zero (deve ser maior que min_obstacle_dist para ter efeito).
 # Consulte também o peso weight_inflation.

 include_dynamic_obstacles: false
 # Se este parâmetro for definido como verdadeiro, o movimento de obstáculos com velocidade diferente de zero (fornecido por meio de obstáculos fornecidos pelo usuário no
 # topic ~/obstacles ou obtido do costmap_converter) é previsto e considerado durante a otimização por meio de um modelo de velocidade constante.

 legacy_obstacle_association: false
 # A estratégia de conectar poses de trajetória com obstáculos para otimização foi modificada (veja changelog).
 # Você pode alternar para a estratégia antiga/anterior definindo este parâmetro como verdadeiro.
 # Estratégia antiga para cada obstáculo, encontre a pose TEB mais próxima
 # Nova estratégia para cada pose de teb, encontre apenas obstáculos "relevantes".

 obstacle_association_force_inclusion_factor: 1.5
 # a estratégia de associação de obstáculos não legados tenta conectar apenas obstáculos relevantes com a trajetória discretizada durante a otimização.
 # Mas todos os obstáculos dentro de uma distância especificada são forçados a serem incluídos (como um múltiplo de min_obstacle_dist).
 # Por exemplo. escolha 2.0 para impor os obstáculos de consideração dentro de um raio de 2.0*min_obstacle_dist.
 # [Este parâmetro é usado apenas se o parâmetro legacy_obstacle_association for false]

 obstacle_association_cutoff_factor: 5
 # Consulte obstáculo_association_force_inclusion_factor, mas além de um múltiplo de [valor]*min_obstacle_dist todos os obstáculos são ignorados durante a otimização.
 # parâmetroobstance_association_force_inclusion_factor é processado primeiro.
 # [Este parâmetro é usado apenas se o parâmetro legacy_obstacle_association for false]

####################################################
# Parâmetros de otimização
####################################################

 no_inner_iterations: 2
 # Número de iterações reais do solver chamadas em cada iteração de loop externo.
 # Consulte o parâmetro no_outer_iterations.

 no_outer_iterations: 2
 # Cada iteração de loop externo redimensiona automaticamente a trajetória de acordo com a resolução temporal desejada dt_ref
 # e invoca o otimizador interno (que executa no_inner_iterations).
 # O número total de iterações do solver em cada ciclo de planejamento é, portanto, o produto de ambos os valores.

 penalty_epsilon: 0.1  
 # pequena margem de segurança para funções de penalidade para aproximações de restrição rígida

 weight_max_vel_x: 1.0 
 # Peso de otimização para satisfazer a velocidade de translação máxima permitida

 weight_max_vel_theta: 1.0 
 # Peso de otimização para satisfazer a velocidade angular máxima permitida

 weight_acc_lim_x: 1.0 
 # Peso de otimização para satisfazer a aceleração translacional máxima permitida 

 weight_acc_lim_theta: 1.0 
 # Peso de otimização para satisfazer a aceleração angular máxima permitida 

 weight_kinematics_nh: 1 # Default 1000.0 => TEMOS UM ROBÔ HOLONOMIC, BASTA ADICIONAR UMA PEQUENA PENALIDADE
 # Peso de otimização para satisfazer a cinemática não holonômica (este parâmetro deve ser alto
 # uma vez que a equação cinemática constitui uma restrição de igualdade, mesmo um valor de 1000 não
 # implica uma condição de matriz ruim devido a pequenos valores de custo 'bruto' em comparação com outros custos).

 weight_kinematics_forward_drive: 10.0
 # Peso de otimização para forçar o robô a escolher apenas direções para frente (velocidades de translação positivas).
 # Um pequeno peso (por exemplo, 1,0) ainda permite dirigir para trás.

 weight_kinematics_turning_radius: 1.0
 # Peso de otimização para impor um raio de giro mínimo (somente para robôs semelhantes a carros).

 weight_optimaltime: 1.0
 # Peso de otimização para contratação da trajetória w.r.t tempo de transição/execução

 weight_obstacle: 100.0
 # Peso de otimização para manter uma distância mínima dos obstáculos

 weight_viapoint: 1.0
 # Peso de otimização para minimizar a distância até os pontos de passagem (resp. caminho de referência). #Novo na versão 0.4

 weight_inflation: 0.1
 # Peso de otimização para a penalidade de inflação (deve ser pequeno).

 weight_adapt_factor: 2.0
 # Alguns pesos especiais (atualmente weight_obstacle) são escalados repetidamente por esse fator em cada iteração TEB externa
 # (peso_novo = peso_antigo*fator).
 # Aumentar os pesos iterativamente em vez de definir um valor enorme a priori leva a melhores condições numéricas de
 # o problema de otimização subjacente.

####################################################
# Planejamento Paralelo em Topologias Distintas
####################################################

 enable_homotopy_class_planning: true
 # Ativar o planejamento paralelo em topologias distintas (
 # requer muito mais recursos de CPU, pois várias trajetórias são otimizadas de uma só vez)

 enable_multithreading: true
 # Ativar encadeamento múltiplo para planejar cada trajetória em um encadeamento diferente

 max_number_classes: 2
 # Especifique o número máximo de trajetórias distintas consideradas
 # (limita o esforço computacional)

 selection_cost_hysteresis: 1.0
 # Especifique quanto custo de trajetória um novo candidato deve ter w.r.t. um previamente selecionado
 # trajetória para ser selecionado (seleção se new_cost < old_cost*factor).

 selection_obst_cost_scale: 100.0
 # Extra dimensionamento de termos de custo de obstáculo apenas para selecionar o 'melhor' candidato.

 selection_viapoint_cost_scale: 1.0
 # Extra dimensionamento de termos de custo de ponto de passagem apenas para selecionar o 'melhor' candidato.

 selection_alternative_time_cost: false
 # Se verdadeiro, o custo do tempo (soma das diferenças de tempo ao quadrado) é substituído pelo total
 # tempo de transição (soma das diferenças de tempo).

 roadmap_graph_no_samples: 15
 # Especifique o número de amostras geradas para criar o gráfico de roteiro

 roadmap_graph_area_width: 6
 # Pontos-chave/pontos de passagem aleatórios são amostrados em uma região retangular entre o início e o objetivo.
 # Especifique a largura dessa região em metros.

 h_signature_prescaler: 1.0
 # Parâmetro interno de escala (assinatura H) que é usado para distinguir entre classes de homotopia.
 # Aviso reduza este parâmetro apenas, se observar problemas com muitos obstáculos no mapa de custo local,
 # não escolha muito baixo, caso contrário os obstáculos não podem ser distinguidos uns dos outros (0,2<valor<=1).

 h_signature_threshold: 0.1
 # Duas assinaturas H são consideradas iguais, se a diferença das partes reais e
 # partes complexas estão abaixo do limite especificado.

 obstacle_heading_threshold: 1.0
 # Especifique o valor do produto escalar entre a direção do obstáculo e a direção da meta
 # para levá-los (obstáculos) em conta para a exploração.

 visualize_hc_graph: false
 # Visualize o gráfico criado para explorar trajetórias distintas
 # (verifique a mensagem do marcador no rviz)

 viapoints_all_candidates: true
 # Se verdadeiro, todas as trajetórias de diferentes topologias são anexadas ao conjunto de pontos de passagem,
 # caso contrário, apenas a trajetória que compartilha a mesma topologia do plano inicial/global é
 # conectado com eles (sem efeito no test_optim_node). Novo na versão 0.4

 switching_blocking_period: 2.0
 # Especifique uma duração de tempo em segundos que precisa ser expirada antes que uma mudança para uma nova classe de equivalência seja permitida.

####################################################
# Parâmetros diversos
####################################################

 odom_topic: odom
 # Nome do tópico da mensagem de odometria, fornecido pelo driver do robô ou simulador.

 map_frame: map
 # Quadro de planejamento global (no caso de um mapa estático, este parâmetro deve ser normalmente alterado para "/map".





